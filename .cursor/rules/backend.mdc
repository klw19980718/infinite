---
alwaysApply: true
---

## Supabase 用法
- 仅通过 `@/lib/supabase` 暴露的 helper 使用：
  - `getSupabaseClient()` 用于 Client 组件。
  - `getServerSupabase()`（或 server action 内）用于服务端。
- 所有查询默认 **RLS 开启**；服务端需要更高权限时，使用**服务端密钥**于 Route Handler（不可在客户端暴露）。

## API & Route Handlers
- API 路由放 /app/api/**，默认 Edge 仅当无 Node 依赖。
- 校验：Zod（或最小手写校验）；返回明确的错误结构 `{ ok:false, code, message }`。
- 禁止在 API 中做 SSR-only 任务与重量级阻塞（交给队列/edge/cron）。

### 🚀 Creem 支付集成
- `/api/creem/checkout` - 创建支付会话，重定向到 Creem 支付页面
- `/api/creem/webhook` - 处理 Creem webhook 事件，更新用户积分
- 环境变量：`CREEM_API_KEY`, `CREEM_WEBHOOK_SECRET`, `CREEM_PRODUCT_*_ID`
- 支付流程：前端 → checkout API → Creem → webhook → 积分更新

## 安全
- 禁止把 `SERVICE_ROLE` 放到任何客户端可达代码/环境变量。
- 对外返回数据**按需**选择字段；永远不要 `select *` 暴露敏感列。
- 限流：如有外部可调用接口，至少按 IP/会话做简单限流。

## 数据库表结构

⚠️ **重要维护提醒**：
- 🔴 当数据库有任何改动时，必须立即更新此文件
- 🔴 保持此表结构与实际数据库同步是强制要求
- 🔴 新增表、修改字段、添加约束时，添加相应的说明注释

### 📊 当前表结构 (2025-01-27)

#### 👤 user_info 表
```sql
- user_id (uuid, 主键) → 关联 auth.users.id
- credits (bigint, 默认: 0) → 用户积分
- created_at (timestamptz, 默认: now())
- updated_at (timestamptz, 默认: now())
```
**用途**: 存储用户积分信息
**RLS**: ✅ 启用

#### 🛍️ products 表
```sql
- id (uuid, 主键, 默认: uuid_generate_v4())
- title (text) → 产品标题
- credits (integer, 约束: > 0) → 积分数量
- price_usd (numeric, 约束: >= 0) → 美元价格
- creem_product_id (text, 唯一) → Creem支付产品ID
- type (product_type枚举, 默认: 'one_time') → 产品类型
  - 枚举值: 'one_time', 'subscription'
- currency (text, 默认: 'USD') → 货币
- active (boolean, 默认: true) → 是否激活
- created_at (timestamptz, 默认: now())
```
**用途**: 存储产品/套餐信息
**RLS**: ✅ 启用

#### 💰 credit_ledger 表
```sql
- id (uuid, 主键, 默认: uuid_generate_v4())
- user_id (uuid) → 关联 auth.users.id
- delta (bigint) → 积分变动量（正数增加，负数减少）
- note (text, 可空) → 变动说明
- created_at (timestamptz, 默认: now())
```
**用途**: 积分变动记录（审计日志）
**RLS**: ✅ 启用

#### 📦 orders 表
```sql
- id (uuid, 主键, 默认: uuid_generate_v4())
- user_id (uuid) → 关联 auth.users.id
- product_id (uuid) → 关联 products.id
- units (integer, 默认: 1, 约束: > 0) → 购买数量
- status (order_status枚举, 默认: 'pending') → 订单状态
  - 枚举值: 'pending', 'paid', 'refunded', 'canceled'
- request_id (text) → 请求ID
- creem_session_id (text, 可空) → Creem会话ID
- creem_order_id (text, 可空) → Creem订单ID
- amount_total_cents (integer, 可空) → 总金额（分）
- currency (text, 可空, 默认: 'USD') → 货币
- created_at (timestamptz, 默认: now())
- paid_at (timestamptz, 可空) → 支付时间
```
**用途**: 订单管理
**RLS**: ✅ 启用

#### 💳 payments 表
```sql
- id (uuid, 主键, 默认: uuid_generate_v4())
- order_id (uuid, 可空) → 关联 orders.id
- provider (text, 默认: 'creem') → 支付提供商
- event_type (text) → 事件类型
- unique_key (text) → 唯一标识
- payload_json (jsonb) → 支付数据（JSON格式）
- created_at (timestamptz, 默认: now())
```
**用途**: 支付事件记录
**RLS**: ✅ 启用

### 🔗 表关系图
```
auth.users (Supabase Auth)
    ↓
user_info (用户积分)
    ↓
credit_ledger (积分变动记录)

products (产品表)
    ↓
orders (订单表) → payments (支付记录)
```

### 📈 数据统计
- **总表数**: 5个
- **有数据的表**: products (3行)
- **空表**: user_info, credit_ledger, orders, payments
- **RLS状态**: 全部启用 ✅

## 触发器与函数（必须保持同步维护）

### credit_ledger ⇒ user_info 同步触发器
```sql
-- 名称：trg_credit_ledger_sync  表：public.credit_ledger  时机：AFTER INSERT/UPDATE/DELETE
-- 函数：public.tg_sync_user_credits()
-- 语义：仅以 ledger 为单一事实来源；任何对 ledger 的增删改都会同步到 user_info.credits
--      INSERT  → user_info.credits += NEW.delta
--      UPDATE  → user_info.credits = credits - OLD.delta + NEW.delta
--      DELETE  → user_info.credits -= OLD.delta
```

### user_info 更新触发器
```sql
-- 名称：trg_user_info_touch  表：public.user_info  时机：BEFORE UPDATE
-- 函数：public.tg_user_info_touch_updated_at()
-- 语义：写入 NEW.updated_at = now()
```

### RPC：public.add_user_credits
```sql
-- 参数：p_user_id uuid, p_credits_to_add bigint, p_note text
-- 权限：SECURITY DEFINER（仅服务端调用）
-- 行为（已修订，避免重复加分）：
--   1) 确保 user_info 行存在（不修改 credits）
--   2) 仅向 credit_ledger 写入一条 +delta 的记录
--      余额变动由触发器 tg_sync_user_credits() 自动完成
```

## Webhook 幂等与订单映射
- 幂等锁：优先插入 payments(unique_key = event.id) 作为“预占位”。若唯一键冲突则直接返回 200，不再加分。
- 次级幂等：若 `orders.creem_session_id = checkout.id` 已存在，则仅更新既有 payments 的 `order_id/payload_json`，不重复计费。
- 产品映射：用 `checkout.order.product` 或 `checkout.product.id` 匹配 `products.creem_product_id`，得到本地 `products.id` 作为 `orders.product_id`。